# Результат домашнего задания к занятию "3.2. Работа в терминале, лекция 2"
1. Команда `cd` является типом встроенной в оболочку. Если данная команда была бы внешней то порождался бы новый процесс со своим окружением и пришлось бы вызывать `bash` из каждой новой директории.
2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?
    * `grep -c <some_string> <some_file>`
3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
    * по данной команде `pstree -p` указывает на родительский процесс всех процессов `systemd`
4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
    * `ls -l /var/log 2>/dev/pts/1`
5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? 
    * `cat < file_input > file_output`
6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
    * Да, например `echo 'Hello World!' > /dev/pts/1`
    * Если одновременно открыть терминалы например `pts0` и `pts1` и передать данную команду из первого терминала во второй, то во втором отобразится текст `Hello World!`
7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
    * `bash 5>&1` - создаст fd 5 и перенаправит его в `stdout (fd=1)`
    * `echo netology > /proc/$$/fd/5` выведет слово `netology` в stdout в который перенаправляет fd 5, ранее созданный
8. `ls -l /tmp/err 5>&2 2>&1 | grep 'No such'`
9. Команда `cat /proc/$$/environ` выведит список переменных окружения. Аналогично данный список можно получить в отформатированном виде командой `env` и `printenv`
10. `/proc/[pid]/cmdline` - в этом файле хранится командная строка, которой был запущен данный процесс. `/proc/[pid]/exe` - представляет собой символическую ссылку на исполняемый файл, который инициировал запуск процесса.
11. `grep sse /proc/cpuinfo` - SSE 4.2
12. По моему мнению команда `ssh localhost tty` не выполняется внутри терминала из-за этого выдает `not a tty`. Чтобы изменить поведение можно воспользоваться ключем `-t` чтобы создать псевдо терминал `ssh -t localhost tty`
13. Например я запустил в обычной SSH сессии команду `top`:
    * ctrl-z перевожу в фоновый режим
    * `ps -a` узнаю pid фонового процесса
    * набираю команду `screen` и в новом окне вызываю команду и передаю ей pid процесс `reptyr 1022`
    * по нажатию клавишь `CTRL-a + d` перехожу в основную ssh сессию
14. Команда `tee` читает из стандартного ввода и записывает его в стандартный вывод и в один или несколько файлов, и в дополнении выводит результат в stdout. Почему не срабатывает команда `sudo echo string > /root/new_file`, потому что исходная оболочка замечает перенаправление и пытается открыть файл для записи перед вызовом `sudo ...` команды. При открытии файла происходит сбой, оболочка даже не вызывает команду, которая должна была записать файл ввиду отсутствия привелегий.